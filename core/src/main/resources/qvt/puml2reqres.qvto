modeltype plantUML "strict" uses plantUML('http://www.elite.xyz/xtext/languages/plantuml/PlantUML');
modeltype reqres "strict" uses RequestResponsePairs('http://www.example.org/RequestResponsePairs');

configuration property diagramName : String;

transformation puml2reqres(in input: plantUML, out output: reqres);

main() {
    log('Started transforming PlantUML to RequestResponse pairs');

    assert fatal ( input.objectsOfType(Model).sequence_diagrams[SQ_Diagram]->size() = 1)
        with log('Input does not contain exactly one SequenceDiagram');

     input.objectsOfType(Model).sequence_diagrams[SQ_Diagram].map transformUmlDiagram();
}

mapping SQ_Diagram::transformUmlDiagram(): Scenario {
    scenarioName := diagramName + "_puml";
    var roundtripId : Integer := 1;

    var elements : OrderedSet(SQ_SequenceElement) := self.elements->flatten_SQ_SequenceElements();
    var elementsSize : Integer := elements->size();
    var elementsIndex : Integer := 1;

    while (elements->notEmpty()) {
        var consumed : OrderedSet(SQ_SequenceElement);
        var elem: SQ_SequenceElement = elements->at(1);

        elements := elements - consumed;
    };
/*
    while (umlElementsIndex <= umlElementsSize) {
        var sequenceElement : SQ_SequenceElement := umlElements->at(umlElementsIndex);
        if (sequenceElement.oclIsTypeOf(UseLeft)) {
            var useLeft : UseLeft := sequenceElement.oclAsType(UseLeft);
            var request : Request := useLeft.useLeft2request();
            var httpRequestElement : HttpRequest := request.request2httpRequest();
            httpRequestElement.receiver := useLeft.userTwo.name;

            umlElementsIndex := umlElementsIndex + 1;
            sequenceElement := umlElements->at(umlElementsIndex);

            if (sequenceElement.oclIsTypeOf(UseLeft)) {
                useLeft := sequenceElement.oclAsType(UseLeft);
                var response : Response := useLeft.useLeft2response();
                var httpResponseElement : HttpResponse := response.response2httpResponse();

                var roundtripElement : Roundtrip := generateRoundtrip(roundtripId, httpRequestElement, httpResponseElement);
                roundtrip += roundtripElement;
                roundtripId := roundtripId + 1;
            }
            elif (sequenceElement.oclIsTypeOf(Alternative)) {
                var httpRequestElementCopy : HttpRequest := new HttpRequest();
                httpRequestElementCopy.httpMethod := httpRequestElement.httpMethod;
                httpRequestElementCopy.url := httpRequestElement.url;
                httpRequestElementCopy.httprequestdatum := httpRequestElement.httprequestdatum;
                httpRequestElementCopy.receiver := httpRequestElement.receiver;

                var alternative : Alternative := sequenceElement.oclAsType(Alternative);
                useLeft := alternative.umlElements->at(1).oclAsType(UseLeft);
                var response : Response := useLeft.useLeft2response();
                var httpResponseElement : HttpResponse := response.response2httpResponse();

                var roundtripElement : Roundtrip := generateRoundtrip(roundtripId, httpRequestElementCopy, httpResponseElement);
                roundtripElement.precondition := alternative.text;
                roundtrip += roundtripElement;
                roundtripId := roundtripId + 1;

                var elseElement : Else := alternative.elseBlocks->at(1).oclAsType(Else);
                useLeft := elseElement.umlElements->at(1).oclAsType(UseLeft);
                response := useLeft.useLeft2response();
                httpResponseElement := response.response2httpResponse();

                roundtripElement := generateRoundtrip(roundtripId, httpRequestElement, httpResponseElement);
                roundtripElement.precondition := elseElement.text;
                roundtrip += roundtripElement;
                roundtripId := roundtripId + 1;

            };
        }
        elif (sequenceElement.oclIsTypeOf(Alternative)) {
            var alternative : Alternative := sequenceElement.oclAsType(Alternative);
            var useLeft : UseLeft := alternative.umlElements->at(1).oclAsType(UseLeft);
            var request : Request := useLeft.useLeft2request();
            var httpRequestElement : HttpRequest := request.request2httpRequest();

            useLeft := alternative.umlElements->at(2).oclAsType(UseLeft);
            var response : Response := useLeft.useLeft2response();
            var httpResponseElement : HttpResponse := response.response2httpResponse();

            var roundtripElement : Roundtrip := generateRoundtrip(roundtripId, httpRequestElement, httpResponseElement);
            roundtripElement.precondition := alternative.text;
            roundtrip += roundtripElement;
            roundtripId := roundtripId + 1;
        };
        umlElementsIndex := umlElementsIndex + 1;
    };
*/
}

helper OrderedSet(SQ_SequenceElement)::flatten_SQ_SequenceElements(): OrderedSet(SQ_SequenceElement) {
    var sequenceElements : OrderedSet(SQ_SequenceElement);
    self->forEach(umlElement) {
        if (umlElement.oclIsTypeOf(SQ_Message)) {
            var message : SQ_Message := umlElement.oclAsType(SQ_Message);
            if (not message.payload.oclIsUndefined()) {
                sequenceElements += message;
            }
        }
        elif (umlElement.oclIsTypeOf(SQ_Group)) {
            var group : SQ_Group := umlElement.oclAsType(SQ_Group);
            sequenceElements += group.map flatten_SQ_Group();
        };
    };
    return sequenceElements;
}

mapping SQ_Group::flatten_SQ_Group(): SQ_Group {
    elements += self.elements->flatten_SQ_SequenceElements();
    alternatives += self.alternatives->at(1).oclAsType(SQ_GroupAlternative).map flatten_SQ_GroupAlternative();
    label := self.label;
}

mapping SQ_GroupAlternative::flatten_SQ_GroupAlternative(): SQ_GroupAlternative {
    elements += self.elements->flatten_SQ_SequenceElements();
    label := self.label;
}

helper SQ_Message::message2request(): PT_RequestResponse {
    var receiver: SQ_Participant;
    if (not self.arrow.lefttip.oclIsUndefined()) {
        receiver := self.participantLeft;
    } else {
        receiver := self.participantRight;
    };

    assert fatal (self.payload != null)
        with log ('Messages without payload are not interesting');

    return self.payload.oclAsType(PT_RequestResponse);
}

helper generateRoundtrip(roundtripId : Integer, httpRequest : HttpRequest, httpResponse : HttpResponse): Roundtrip {
    var roundtripElement : Roundtrip := new Roundtrip();
    roundtripElement.roundtripName := "roundtrip" + roundtripId.toString();
    roundtripElement.httprequest := httpRequest;
    roundtripElement.httpresponse := httpResponse;
    return roundtripElement;
}

mapping PT_Request::request2httpRequest():HttpRequest {
    httpMethod := self.method;
    url := self.url;
    httprequestdatum += self.parametermap.params->map param2httpRequestDatum();
}

mapping PT_Response::response2httpResponse(): HttpResponse {
    // TODO: don't mansch together
    httpStatus := self.acceptedcodes->toString();
    httpresponsedatum += self.parametermap.params->map param2httpResponseDatum();
}

mapping PT_Parameter::param2httpRequestDatum(): HttpRequestDatum {
    variableName := self.name;
    value := self.value;
}

mapping PT_Parameter::param2httpResponseDatum(): HttpResponseDatum {
    variableName := self.name;
    xPath := self.value;
}
