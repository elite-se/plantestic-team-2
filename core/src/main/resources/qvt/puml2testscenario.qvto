modeltype plantUML "strict" uses plantUML('http://www.elite.xyz/xtext/languages/plantuml/PlantUML');
modeltype testscenario "strict" uses TestScenario('http://elite-se.xyz/TestScenario');

transformation puml2reqres(in input: plantUML, out output: testscenario);

configuration property diagramName : String;

main() {
    log('Started transforming PlantUML to RequestResponse pairs');

    assert fatal ( input.objectsOfType(Model).sequence_diagrams[SQ_Diagram]->size() = 1)
        with log('Input does not contain exactly one SequenceDiagram');

    var configs = input.objectsOfType(Model).configs[SQ_Config].map transformConfigs();
    input.objectsOfType(Model).sequence_diagrams[SQ_Diagram].map transformUmlDiagram(configs);
    log("Output configs: " + configs->size().toString());
}

mapping SQ_Config::transformConfigs(): Config {
    entries := self.entries.map transformConfigEntries();
}

mapping SQ_ConfigEntry::transformConfigEntries(): ConfigEntry {
    key := self.name;
    value := self.value;
}

mapping SQ_Diagram::transformUmlDiagram(configs_ : Bag(Config)): TestScenario {
    testScenarioName := diagramName + "_puml";
    configs := configs_;
    var roundtripCounter : Integer := 1;
    
    var elements := self.elements->flatten_SQ_SequenceElements()->asList();
    log("Elements: " + elements->size().toString());
    
	structure := elements->structures(1,0).structure;

    log("Discovered " + structure->size().toString() + " structures");
}

helper findRequest(response: SQ_Message, preceedingElements: Sequence(SQ_SequenceElement)) : Tuple(index: Integer, requestMsg: SQ_Message) {
	var potInd := 0;
	var preceedingRev := preceedingElements->reverse();
	while (potInd <= preceedingRev->size()) {
		potInd := potInd + 1;
		if (preceedingRev->at(potInd).oclIsTypeOf(SQ_Message)) {
			var msg = preceedingRev->at(potInd).oclAsType(SQ_Message);
			if (msg.isRequest() 
				and msg.sender().name = response.receiver().name
				and msg.receiver().name = response.sender().name) {
				return Tuple{index = potInd, requestMsg = msg};
			}
		}	
	};
	
	return null;
}

helper OrderedSet(SQ_SequenceElement)::flatten_SQ_SequenceElements(): OrderedSet(SQ_SequenceElement) {
    var sequenceElements : OrderedSet(SQ_SequenceElement);
    self->forEach(umlElement) {
        if (umlElement.oclIsTypeOf(SQ_Message)) {
            var message : SQ_Message := umlElement.oclAsType(SQ_Message);
            if (not message.payload.oclIsUndefined()) {
								// TODO: tmp
								if (message.isRequest()) {
									log("\tDiscovered Request: " + 
										message.participantLeft.name.toString() + 
										" " + message.arrow.lefttip.toString() + message.arrow.righttip.toString() +
										" " + message.participantRight.name.toString()
									);
								} elif (message.isResponse()) {
									log("\tDiscovered Response: " + 
										message.participantLeft.name.toString() + 
										" " + message.arrow.lefttip.toString() + message.arrow.righttip.toString() +
										" " + message.participantRight.name.toString()
									);
								};


                sequenceElements += message;
            };
        }
        elif (umlElement.oclIsTypeOf(SQ_Group)) {
            var group : SQ_Group := umlElement.oclAsType(SQ_Group);

						// TODO: temp
						log("\tDiscovered Group: " + group.keyword.toString() + " " + group.label.toString() + " (" + group.elements->size().toString() + ")");

            sequenceElements += group.map flatten_SQ_Group();
        };
    };
    return sequenceElements;
}

mapping SQ_Group::flatten_SQ_Group(): SQ_Group {
    elements += self.elements->flatten_SQ_SequenceElements();
    alternatives += self.alternatives->oclAsType(SQ_GroupAlternative).map flatten_SQ_GroupAlternative();
    label := self.label;
}

mapping SQ_GroupAlternative::flatten_SQ_GroupAlternative(): SQ_GroupAlternative {
    elements += self.elements->flatten_SQ_SequenceElements();
    label := self.label;
}

helper SQ_Arrow::isR2L(): Boolean {
    return not self.lefttip.oclIsUndefined() and self.righttip.oclIsUndefined();
}

helper SQ_Arrow::isL2R(): Boolean {
    return self.lefttip.oclIsUndefined() and not self.righttip.oclIsUndefined();
}

helper SQ_Message::receiver(): SQ_Participant {
    if (self.arrow.isR2L()) {
        return self.participantLeft;
    } else if (self.arrow.isL2R()) {
        return self.participantRight;
    };
    return null;
}

helper SQ_Message::sender(): SQ_Participant {
    if (self.arrow.isR2L()) {
        return self.participantRight;
    } else if (self.arrow.isL2R()) {
        return self.participantLeft;
    };
    return null;
}

helper SQ_Message::isRequest(): Boolean {
    return not self.payload.request.oclIsUndefined();
}

helper SQ_Message::isResponse(): Boolean {
    return not self.payload.response.oclIsUndefined();
}

helper generateRoundtrip(roundtripId : Integer, request : RequestSpecification, response : ResponseSpecification): TestRoundtrip {
	return object TestRoundtrip {
		testRoundtripName := "roundtrip" + roundtripId.toString();
		requestspecification := request;
		responsespecification := response;
	};
}

mapping SQ_Message::message2request(): RequestSpecification {
	assert fatal (not self.payload.request.oclIsUndefined())
		with log('Message should have contained a request');

	method := self.payload.request.method;
    url := self.payload.request.url;
	receiver := self.receiver().name;
	sender := self.sender().name;
	requestdatum := self.payload.request.parametermap.params->map param2requestDatum();
}

mapping SQ_Message::message2response(): ResponseSpecification {
	assert fatal (not self.payload.response.oclIsUndefined())
		with log('Message should have contained a response');
		
	responsedatum := self.payload.response.parametermap.params->map param2responseDatum();

    if(self.payload.response.acceptedcodes->notEmpty()) {
        statusmatcher := object IsIn {
           value := self.payload.response.acceptedcodes.code.toString();
        };
    };

    var bodyMatcherGroup = object BodyMatcherGroup {};
    responsedatum->forEach(rd) {
    	var bodyMatcher = object BodyMatcher {};
       	bodyMatcher.matcher := object HasXPath {
			xPath := rd.xPath;
	  	};
       	bodyMatcherGroup.bodymatcher += bodyMatcher;
    };
    bodymatchergroup := bodyMatcherGroup;
}

mapping PT_Parameter::param2requestDatum(): RequestDatum {
    variableName := self.name;
    value := self.value;
}

mapping PT_Parameter::param2responseDatum(): ResponseDatum {
    variableName := self.name;
    xPath := self.value;
}

helper SQ_Group::toAlternative(roundtripIdStart: Integer, preceeding: List(SQ_SequenceElement)): Tuple(structure: Alternative, roundtripCnt: Integer, newPreceeding: List(SQ_SequenceElement)) {
	var alternative := object Alternative {};
	var roundtripCnt := roundtripIdStart;
	var elems := object List(SQ_SequenceElement) {};
	preceeding->forEach(e) { elems->add(e); };
	self.elements->forEach(e) { elems->add(e); };
	
	var res := elems->structures(roundtripCnt+1, preceeding->size()+1);

	var newPreceeding := object List(SQ_SequenceElement) {};
	res.elements->forEach(e) {
		if (preceeding->includes(e)) {
			newPreceeding += e;
		};
	};
	roundtripCnt := res.roundtripCnt;

	alternative.condition := self.label;
	alternative.provided := res.structure->asOrderedSet();
	
	if (self.alternatives->size() > 0) {
		var alt1 := self.alternatives->at(1);
		var othr := object SQ_Group {
			keyword := self.keyword;
			label := alt1.label;
			alternatives := self.alternatives->subOrderedSet(2, self.alternatives->size());
			elements := alt1.elements;
		};
		
		var res2 := othr.toAlternative(roundtripCnt, newPreceeding);
		alternative.otherwise := res2.structure;
		
		newPreceeding := object List(SQ_SequenceElement) {};
		res2.newPreceeding->forEach(e) {
			if (preceeding->includes(e)) {
				newPreceeding += e;
			}
		};
		roundtripCnt := res2.roundtripCnt;
	};
	
	return Tuple { structure = alternative, roundtripCnt = roundtripCnt, newPreceeding = newPreceeding };
}

helper List(SQ_SequenceElement)::structures(roundtripIdStart: Integer, elemStartInd: Integer): Tuple(structure: List(Structure), elements: List(SQ_SequenceElement), roundtripCnt: Integer) {
	var structures := object List(Structure) {};
	var roundtripCnt := roundtripIdStart;
	var elements := self;
	
	var elemInd := elemStartInd;
	while (elemInd <= elements->size()) {
		assert fatal (elemInd >= 0)
			with log('INTERNAL: logic tried accessing index < 0');
	
		elemInd := elemInd + 1;
		var elem := elements->at(elemInd);
		var prec := self->subSequence(1, elemInd);
		
		if (elem.oclIsTypeOf(SQ_Message)) {
    		var msg := elem.oclAsType(SQ_Message);
    		
    		if (msg.isResponse()) {
				var reqT := findRequest(msg, prec);
				
				// No match found
				if (reqT.oclIsUndefined()) {
					log ("Could not find matching request for response: " + msg.toString());
					elements->removeAt(elemInd);
					elemInd := elemInd - 1;
				} else {
					var request := reqT.requestMsg.map message2request();
					var response := msg.map message2response();
					structures += generateRoundtrip(roundtripCnt, request, response);
					roundtripCnt := roundtripCnt + 1;
					
					// Order is important as remove invalidates indices!
					elements->removeAt(elemInd);
					elements->removeAt(reqT.index);
				}
    		}
    	} elif (elem.oclIsTypeOf(SQ_Group)) {
    		var res := elem.oclAsType(SQ_Group).toAlternative(roundtripCnt, prec);
    		structures += res.structure;
    		roundtripCnt := res.roundtripCnt + 1;
    		
    		var elems := object List(SQ_SequenceElement) {};
    		res.newPreceeding->forEach(e) {
    			if (prec->includes(e)) {
    				elems += e;
    			}
    		};
    		elements->forEach(e) {
    			if (not prec->includes(e)) {
    				elems +=e;
    			}
    		};
    		elemInd := elements->size() - elems->size();
			elements := elems;
    	}
	};
	
	return null;
}