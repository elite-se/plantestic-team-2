modeltype plantUML "strict" uses plantUML('http://www.elite.xyz/xtext/languages/plantuml/PlantUML');
modeltype testscenario "strict" uses TestScenario('http://elite-se.xyz/TestScenario');

transformation puml2reqres(in input: plantUML, out output: testscenario);

configuration property diagramName : String;

main() {
    log('Started transforming PlantUML to RequestResponse pairs');

    assert fatal ( input.objectsOfType(Model).sequence_diagrams[SQ_Diagram]->size() = 1)
        with log('Input does not contain exactly one SequenceDiagram');

    var configs = input.objectsOfType(Model).configs[SQ_Config].map transformConfigs();
    input.objectsOfType(Model).sequence_diagrams[SQ_Diagram].map transformUmlDiagram(configs);
    log("Output configs: " + configs->size().toString());
}

mapping SQ_Config::transformConfigs(): Config {
    entries := self.entries.map transformConfigEntries();
}

mapping SQ_ConfigEntry::transformConfigEntries(): ConfigEntry {
    key := self.name;
    value := self.value;
}

mapping SQ_Diagram::transformUmlDiagram(configs_ : Bag(Config)): TestScenario {
    testScenarioName := diagramName + "_puml";
    configs := configs_;
    var roundtripCounter : Integer := 1;
    
	structure := self.elements->flatten_SQ_SequenceElements("")->asList()->structures("", 1, 1).structure;

    log("Discovered " + structure->size().toString() + " structures");
}

helper findRequest(msgPrefix: String, response: SQ_Message, preceedingElements: Sequence(SQ_SequenceElement)) : Tuple(index: Integer, requestMsg: SQ_Message) {
	log(msgPrefix + "FIND REQUEST: " + response.humanReadableString());
	var potInd := 0;
	var preceedingRev := preceedingElements->reverse();
	while (potInd <= preceedingRev->size()) {
		potInd := potInd + 1;
		var precElem := preceedingRev->at(potInd);
		if (precElem.oclIsTypeOf(SQ_Message)) {
			var msg = precElem.oclAsType(SQ_Message);
			log(msgPrefix + "  * " + msg.humanReadableString());
			if (msg.isRequest() 
				and msg.sender().name = response.receiver().name
				and msg.receiver().name = response.sender().name) {
				
				log(msgPrefix + "  FOUND: " + msg.humanReadableString());
				log(msgPrefix + "END FIND REQUEST");
				return Tuple{index = potInd, requestMsg = msg};
			}
		}	
	};
	
	log(msgPrefix + "  NOTHING FOUND");
	log(msgPrefix + "END FIND REQUEST");
	return null;
}

helper OrderedSet(SQ_SequenceElement)::flatten_SQ_SequenceElements(msgPrefix: String): OrderedSet(SQ_SequenceElement) {
	log(msgPrefix + "START ELEMENTS");

    var sequenceElements : OrderedSet(SQ_SequenceElement);
    self->forEach(umlElement) {
        if (umlElement.oclIsTypeOf(SQ_Message)) {
            var message : SQ_Message := umlElement.oclAsType(SQ_Message);
            
            log(msgPrefix + "MESSAGE: " + message.humanReadableString());

            if (not message.payload.oclIsUndefined()) {
                sequenceElements += message;
            };
        }
        elif (umlElement.oclIsTypeOf(SQ_Group)) {
            var group : SQ_Group := umlElement.oclAsType(SQ_Group);
            sequenceElements += group.map flatten_SQ_Group(msgPrefix);
        };
    };
    
	log(msgPrefix + "END ELEMENTS");
    return sequenceElements;
}

mapping SQ_Group::flatten_SQ_Group(msgPrefix: String): SQ_Group {
	log(msgPrefix + "START GROUP: " + self.humanReadableString());

	keyword := self.keyword;
    elements += self.elements->flatten_SQ_SequenceElements(msgPrefix + "  ");
    alternatives += self.alternatives->oclAsType(SQ_GroupAlternative).map flatten_SQ_GroupAlternative(msgPrefix);
    label := self.label;
    
	log(msgPrefix + "END GROUP");
}

mapping SQ_GroupAlternative::flatten_SQ_GroupAlternative(msgPrefix: String): SQ_GroupAlternative {
	log(msgPrefix + "START ALTERNATIVE: else" + " " + self.label.toString() + " (" + self.elements->size().toString() + ")");

    elements += self.elements->flatten_SQ_SequenceElements(msgPrefix + "  ");
    label := self.label;
    
	log(msgPrefix + "END ALTERNATIVE");
}

helper SQ_Arrow::isR2L(): Boolean {
    return not self.lefttip.oclIsUndefined() and self.righttip.oclIsUndefined();
}

helper SQ_Arrow::isL2R(): Boolean {
    return self.lefttip.oclIsUndefined() and not self.righttip.oclIsUndefined();
}

helper SQ_Message::receiver(): SQ_Participant {
    if (self.arrow.isR2L()) {
        return self.participantLeft;
    } else if (self.arrow.isL2R()) {
        return self.participantRight;
    };
    return null;
}

helper SQ_Message::sender(): SQ_Participant {
    if (self.arrow.isR2L()) {
        return self.participantRight;
    } else if (self.arrow.isL2R()) {
        return self.participantLeft;
    };
    return null;
}

helper SQ_Message::isRequest(): Boolean {
    return not self.payload.request.oclIsUndefined();
}

helper SQ_Message::isResponse(): Boolean {
    return not self.payload.response.oclIsUndefined();
}

helper generateRoundtrip(msgPrefix: String, roundtripId : Integer, request : RequestSpecification, response : ResponseSpecification): TestRoundtrip {
	log(msgPrefix + "GENERATING Roundtrip: " + roundtripId.toString() + ": " + request.humanReadableString());
	
	return object TestRoundtrip {
		testRoundtripName := "roundtrip" + roundtripId.toString();
		requestspecification := request;
		responsespecification := response;
	};
}

mapping SQ_Message::message2request(): RequestSpecification {
	assert fatal (not self.payload.request.oclIsUndefined())
		with log('Message should have contained a request');

	method := self.payload.request.method;
    url := self.payload.request.url;
	receiver := self.receiver().name;
	sender := self.sender().name;
	requestdatum := self.payload.request.parametermap.params->map param2requestDatum();
}

mapping SQ_Message::message2response(): ResponseSpecification {
	assert fatal (not self.payload.response.oclIsUndefined())
		with log('Message should have contained a response');
		
	responsedatum := self.payload.response.parametermap.params->map param2responseDatum();

    if(self.payload.response.acceptedcodes->notEmpty()) {
        statusmatcher := object IsIn {
           value := self.payload.response.acceptedcodes.code.toString();
        };
    };

    var bodyMatcherGroup = object BodyMatcherGroup {};
    responsedatum->forEach(rd) {
    	var bodyMatcher = object BodyMatcher {};
       	bodyMatcher.matcher := object HasXPath {
			xPath := rd.xPath;
	  	};
       	bodyMatcherGroup.bodymatcher += bodyMatcher;
    };
    bodymatchergroup := bodyMatcherGroup;
}

mapping PT_Parameter::param2requestDatum(): RequestDatum {
    variableName := self.name;
    value := self.value;
}

mapping PT_Parameter::param2responseDatum(): ResponseDatum {
    variableName := self.name;
    xPath := self.value;
}

helper SQ_Group::toAlternative(msgPrefix: String, roundtripIdStart: Integer, preceeding: List(SQ_SequenceElement)): Tuple(structure: Alternative, roundtripCnt: Integer, newPreceeding: List(SQ_SequenceElement)) {
	log(msgPrefix + "TO ALTERNATIVE (rdID=" + roundtripIdStart.toString() + ", #prec=" + preceeding->size().toString() + ")");
	var alternative := object Alternative {};
	var roundtripCnt := roundtripIdStart;
	var elems := object List(SQ_SequenceElement) {};
	preceeding->forEach(e) { elems->add(e); };
	self.elements->forEach(e) { elems->add(e); };
	
	var res := elems->structures(msgPrefix, roundtripCnt, preceeding->size()+1);

	var newPreceeding := object List(SQ_SequenceElement) {};
	res.elements->forEach(e) {
		if (preceeding->includes(e)) {
			newPreceeding += e;
		};
	};
	roundtripCnt := res.roundtripCnt;

	alternative.condition := self.label;
	alternative.provided := res.structure->asOrderedSet();
	
	if (self.alternatives->size() > 0) {
		var alt1 := self.alternatives->at(1);
		var othr := object SQ_Group {
			keyword := self.keyword;
			label := alt1.label;
			alternatives := self.alternatives->subOrderedSet(2, self.alternatives->size());
			elements := alt1.elements;
		};
		
		var res2 := othr.toAlternative(msgPrefix + "  ", roundtripCnt, newPreceeding);
		alternative.otherwise := res2.structure;
		
		newPreceeding := object List(SQ_SequenceElement) {};
		res2.newPreceeding->forEach(e) {
			if (preceeding->includes(e)) {
				newPreceeding += e;
			}
		};
		roundtripCnt := res2.roundtripCnt;
	};
	
	log(msgPrefix + "END ALTERNATIVE");
	return Tuple { structure = alternative, roundtripCnt = roundtripCnt, newPreceeding = newPreceeding };
}

helper List(SQ_SequenceElement)::structures(msgPrefix: String, roundtripIdStart: Integer, elemStartInd: Integer): Tuple(structure: List(Structure), elements: List(SQ_SequenceElement), roundtripCnt: Integer) {
	log(msgPrefix + "BEGIN STRUCTURES #" + self->size().toString() + " (rtID=" + roundtripIdStart.toString() + ", elemStart=" + elemStartInd.toString() + ")");

	var structures := object List(Structure) {};
	var roundtripCnt := roundtripIdStart;
	var elements := self;
	
	var elemInd := elemStartInd;
	while (elemInd <= elements->size()) {
		assert fatal (elemInd >= 0)
			with log('INTERNAL: logic tried accessing index < 0');
	
		var elem := elements->at(elemInd);
		var prec := self->subSequence(1, elemInd-1);
		elemInd := elemInd + 1;
		
		if (elem.oclIsTypeOf(SQ_Message)) {
    		var msg := elem.oclAsType(SQ_Message);
    		log(msgPrefix + "  message(" + elemInd.toString() + "): " + msg.humanReadableString());
    		
    		if (msg.isResponse()) {
				var reqT := findRequest(msgPrefix + "  ", msg, prec);
				
				// No match found
				if (reqT.oclIsUndefined()) {
					log (msgPrefix + "Could not find matching request for response: " + msg.toString());
					elements->removeAt(elemInd);
					elemInd := elemInd - 1;
				} else {
					var request := reqT.requestMsg.map message2request();
					var response := msg.map message2response();
					structures += generateRoundtrip(msgPrefix + "  " , roundtripCnt, request, response);
					roundtripCnt := roundtripCnt + 1;
					
					// Order is important as remove invalidates indices!
					elements->removeAt(elemInd);
				}
    		}
    	} elif (elem.oclIsTypeOf(SQ_Group)) {
    		var grp = elem.oclAsType(SQ_Group);
    		log(msgPrefix + "  " + grp.humanReadableString());
    		
    		var res := grp.toAlternative(msgPrefix + "  ", roundtripCnt, prec);
    		structures += res.structure;
    		roundtripCnt := res.roundtripCnt + 1;
    		
    		var elems := object List(SQ_SequenceElement) {};
    		res.newPreceeding->forEach(e) {
    			if (prec->includes(e)) {
    				elems += e;
    			}
    		};
    		elements->forEach(e) {
    			if (not prec->includes(e)) {
    				elems +=e;
    			}
    		};
			elements := elems;
    	}
	};
	
	log(msgPrefix + "END STRUCTURES");
	return Tuple { structure = structures, elements = elements, roundtripCnt = roundtripCnt };
}

helper SQ_Message::humanReadableString(): String {
	var str := "";
	
	// Parse left participant (if any)
	if (not self.participantLeft.oclIsUndefined()) {
		str := str + self.participantLeft.name + " ";
	};
	
	// Parse arrow
	if (not self.arrow.leftmodifier.oclIsUndefined()) {
		str := str + self.arrow.leftmodifier;
	};
	if (not self.arrow.lefttip.oclIsUndefined()) {
		str := str + self.arrow.lefttip.toString();
	};
	self.arrow.line->forEach(l) {
		str := str + l;
	};
	if (not self.arrow.righttip.oclIsUndefined()) {
		str := str + self.arrow.righttip.toString();
	};
	if (not self.arrow.rightmodifier.oclIsUndefined()) {
		str := str + self.arrow.rightmodifier;
	};
	
	// Parse right participant (if any)
	if (not self.participantRight.oclIsUndefined()) {
		str := str + " " + self.participantRight.name;
	};
	
	// Parse payload (if any)
	if (not self.payload.oclIsUndefined()) {
		if (not self.payload.asyncid.oclIsUndefined() and self.payload.asyncid != 0) {
			str := str + " : async[" + self.payload.asyncid.toString() + "]";
		};
		
		if (not self.payload.request.oclIsUndefined()) {
			str := str + " request(" + self.payload.request.method + ", " + self.payload.request.url + ", {...})";
		} elif (not self.payload.response.oclIsUndefined()) {
			str := str + " response(";
			self.payload.response.acceptedcodes->forEach(ac) {
				str := str + ac.code.toString() + " " + ac.description + ", ";
			};
			str := str + ")";
		};
		
		if (not self.description.oclIsUndefined()) {
			str := str + " " + self.description;
		};
	} elif (not self.description.oclIsUndefined()) {
		str := str + " : " + self.description;
	};
	
	
	if (not self.payload.oclIsUndefined()) {
		str := str + " (isRequest=" + self.isRequest().toString() + ")";
	};
	
	return str;
}

helper RequestSpecification::humanReadableString(): String {
	return "request(method=" + self.method + ", url=\"" + self.url + "\", sender=" + self.sender + ", receiver=" + self.receiver + ")";
}

helper SQ_Group::humanReadableString(): String {
	return self.keyword.toString() + " " + self.label.toString() + " (#elems=" + self.elements->size().toString() + ", #alternatives=" + self.alternatives->size().toString() + ")";
}